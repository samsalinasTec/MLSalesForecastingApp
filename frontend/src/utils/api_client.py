"""Utility functions to communicate with the FastAPI backend."""

from __future__ import annotations

import re
from typing import Any, Dict, List, Optional, Tuple, Union

import httpx


def _normalize_timeout(value: Union[float, int, httpx.Timeout, None]) -> httpx.Timeout:
    """
    Normaliza el timeout:
    - float/int -> se interpreta como timeout total (httpx lo reparte internamente).
    - None -> usa valores por fase adecuados para backend "lento" (BigQuery).
    - httpx.Timeout -> se respeta tal cual.
    """
    if isinstance(value, httpx.Timeout):
        return value
    if isinstance(value, (float, int)):
        return httpx.Timeout(value)  # total
    # Default “sano”: conexiones rápidas, lectura larga
    return httpx.Timeout(connect=5.0, read=300.0, write=30.0, pool=5.0)


class APIClient:
    """Thin HTTP client tailored to the MLSalesForecasting backend."""

    def __init__(
        self,
        base_url: str,
        timeout: Union[float, int, httpx.Timeout, None] = None,
        *,
        max_keepalive_connections: int = 10,
        max_connections: int = 20,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = _normalize_timeout(timeout)
        self.limits = httpx.Limits(
            max_keepalive_connections=max_keepalive_connections,
            max_connections=max_connections,
        )

    def _get_client(self) -> httpx.Client:
        return httpx.Client(
            base_url=self.base_url,
            timeout=self.timeout,
            limits=self.limits,
        )

    def get_active_sorteos(self) -> Dict[str, Any]:
        """Fetch active draws grouped by ``SorteoType``."""
        with self._get_client() as client:
            r = client.get("/predictions/active")
            r.raise_for_status()
            return r.json()

    def create_predictions(
        self,
        sorteo_types: List[str],
        apply_smoothing: bool,
        force_recalculation: bool,
        save_to_bq: bool = False,
    ) -> Dict[str, Any]:
        """Trigger predictions for the selected ``SorteoType`` values."""
        payload = {
            "sorteo_types": sorteo_types,
            "apply_smoothing": apply_smoothing,
            "force_recalculation": force_recalculation,
            "save_to_bq": save_to_bq,
        }
        with self._get_client() as client:
            r = client.post("/predictions/", json=payload)
            r.raise_for_status()
            return r.json()

    def download_prediction_summary(self) -> Tuple[bytes, str]:
        """Download the CSV summary generated by the backend."""
        with self._get_client() as client:
            r = client.get("/predictions/summary/download")
            r.raise_for_status()
            filename = self._parse_filename(r.headers.get("content-disposition", "")) or "resumen_predicciones.csv"
            return r.content, filename

    @staticmethod
    def _parse_filename(content_disposition: str) -> Optional[str]:
        """Extract the filename from a Content-Disposition header."""
        match = re.search(r"filename\*=UTF-8''([^;]+)", content_disposition)
        if match:
            return httpx.URL(match.group(1)).decoded
        match = re.search(r'filename="?([^";]+)"?', content_disposition)
        if match:
            return match.group(1)
        return None
